// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int       @id @default(autoincrement())
  email       String    @unique
  password    String
  firstName   String
  lastName    String
  major       Department @relation(fields: [departmentId], references: [id])
  departmentId Int
  reviews     Review[]
  timetables  TimeTable[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model Department {
  id          Int       @id @default(autoincrement())
  name        String
  courses     Course[]
  professors  Professor[]
  users       User[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model Professor {
  id          Int       @id @default(autoincrement())
  firstName   String
  lastName    String
  departments Department[] @relation("DepartmentProfessors")
  courses     Course[] @relation("CourseProfessors")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model Course {
  id          Int       @id @default(autoincrement())
  name        String
  code        String
  department  Department @relation(fields: [departmentId], references: [id])
  departmentId Int
  lectures    Lecture[]
  professors  Professor[] @relation("CourseProfessors")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model Lecture {
  id          Int       @id @default(autoincrement())
  name        String
  course      Course    @relation(fields: [courseId], references: [id])
  courseId    Int
  timetable   TimeTable[]
  reviews     Review[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model Review {
  id          Int       @id @default(autoincrement())
  content     String
  rating      Int
  user        User      @relation(fields: [userId], references: [id])
  userId      Int
  lecture     Lecture   @relation(fields: [lectureId], references: [id])
  lectureId   Int
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model TimeTable {
  id          Int       @id @default(autoincrement())
  semester    Semester  @relation(fields: [semesterId], references: [id])
  semesterId  Int
  user        User      @relation(fields: [userId], references: [id])
  userId      Int
  lectures    Lecture[] @relation("LectureTimeTable")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

model Semester {
  id          Int       @id @default(autoincrement())
  year        Int
  term        String
  timetables  TimeTable[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime? // Used for soft delete
}

// Many-to-many relation helpers

model LectureTimeTable {
  lecture   Lecture  @relation(fields: [lectureId], references: [id])
  lectureId Int
  timetable TimeTable @relation(fields: [timetableId], references: [id])
  timetableId Int
  createdAt  DateTime @default(now())

  @@id([lectureId, timetableId])
}

model DepartmentProfessors {
  department Department @relation(fields: [departmentId], references: [id])
  departmentId Int
  professor  Professor @relation(fields: [professorId], references: [id])
  professorId Int
  createdAt  DateTime @default(now())

  @@id([departmentId, professorId])
}

model CourseProfessors {
  course    Course    @relation(fields: [courseId], references: [id])
  courseId  Int
  professor Professor @relation(fields: [professorId], references: [id])
  professorId Int
  createdAt  DateTime @default(now())

  @@id([courseId, professorId])
}

// Soft delete middleware
// This can be set up in your Nest.js application to intercept delete calls
middleware softDelete = async (params, next) => {
  if (params.action === 'delete') {
    params.action = 'update';
    params.args['data'] = { deletedAt: new Date() };
  }
  if (params.action === 'deleteMany') {
    params.action = 'updateMany';
    params.args['data'] = { deletedAt: new Date() };
  }
  return next(params);
}

prisma.$use(softDelete);